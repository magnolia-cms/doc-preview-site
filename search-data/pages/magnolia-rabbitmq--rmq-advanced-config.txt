---
title: "RMQ advanced configuration"
url: https://docs.magnolia-cms.com/magnolia-rabbitmq/rmq-advanced-config/
category: Modules
version: modules
breadcrumb: RMQ Publication module > RMQ advanced configuration
---

# RMQ advanced configuration

This page provides information about advanced configuration scenarios and troubleshooting.

| Instance | Message ID | Timestamp |
| --- | --- | --- |
| **Public 1** | `4` | `1441631639` |
| **Public 2** | `4` | `1441631639` |
| **Public 3** | `3` | `1441631639` |

## [](#_continuous_deployment_strategy)Continuous deployment strategy

### [](#_how_to_synchronize_new_public_instances)How to synchronize new public instances

Public instance backups should be done when the SyncState message id is identical for all public nodes. You can then choose one public node and to do a dump. Once the dump is done, create a new historical queue and empty the old queue by consuming all messages. The instance will then be ready to receive new activation messages which post-date the last dump.

Whenever you need to create a new instance, always use the latest dump. The new instance will be registered to the new historical queue. This will mean that the message id is in SyncState with the latest activation message. New activation messages will be sent to the new historical queue before they register in the old historical queue. The new historical queue will start getting all messages after the last message in old historical queue.

### [](#_adding_new_instances)Adding new instances

This series of diagrams shows the best setup for scaling up when adding new public instances to the load balancer.

1.  The basic idea is to always keep a spare queue (which does not have a consumer) connected to the exchange.

    ![spare queue diagram](../_images/advanced-config/spare-queue-diagram.jpg)

2.  The spare queue stores all activation messages until a new consumer connects. The newly created instance is created with the same initial data as Public 1.

    ![new instance diagram](../_images/advanced-config/new-instance-diagram.jpg)

3.  Public 2 is created with the same data set as Public 1. Before Public 2 starts consuming a new queue (without a consumer) is created.

    ![backup diagram](../_images/advanced-config/backup-diagram.jpg)

4.  Once the remaining messages are consumed a backup is created. This serves as the new state for new instances. This is also the time to add the new public instance to the load balancer.

    When to do a backup?

    Each message has a version number or tag in its header. When a new public is added it can tell the author instance or the exchange about its presence by sending its identity before consuming starts. This enables the exchange or author to create the new queue for the public instance.

    From this point, all activation messages contain a new version or tag and the consumer starts consuming messages in the queue. When the consumer comes across a message with the newest version number, it does the backup.

5.  Activation continues and the spare queue (queue\_pub\_3) is filled with new messages that represent the difference between Public 2 and newest content.

    ![activation diagram](../_images/advanced-config/activation-diagram.jpg)


> **Important:** Regular backups are needed to prevent the queue becoming too big. Whenever you do a backup on the instances the spare queue can be emptied.

### [](#_adding_a_queue_after_backup)Adding a queue after backup

This example shows you how to add a new queue to the example `testfanoutAck` exchange:

1.  Add the queue.

    ```sh
    curl -i -u guest:guest -H "content-type:application/json" \
      -XPUT -d'{"auto_delete":false,"durable":true,"arguments":{},"node":"rabbit@localhost"}' \
      http://localhost:55672/api/queues/%2f/fan2
    ```

2.  Declare it to be bound to correct exchange.

    ```sh
    curl -i -u guest:guest -H "content-type:application/json" \
       -d'{"routing_key":"","arguments":[]}' \
      http://localhost:55672/api/bindings/%2f/fan2/testfanoutAck
    ```


## [](#_ack_queue_blocked_by_unacknowledged_node)ACK queue blocked by unacknowledged node

When a consumer encounters an issue because of an activation exception, the consumer stops consuming. The message is sent back to the queue with a non-ack, and an exception is sent over the ACK exchange.

To illustrate this we deleted a node on the public instance and then tried to deactivate it on the author instance.

The deletion and attempted deactivation resulted in the following error:

```sh
ERROR lia.rabbitmq.activation.jobs.ActivationConsumerJob: /bla
```

> **Note:** he exception is visible in the Public Monitoring app. You can see from the PathNotFoundException that the consumer did not find the path that was deleted directly of the public instance.

![acl queue blocked app](../_images/advanced-config/acl-queue-blocked-app.jpg)

In the RabbitMQ console the:

-   Message is not consumed in the queue.

-   Message is marked unacked.

-   Consumer is gone.


![acl queue blocked rabbitmq](../_images/advanced-config/acl-queue-blocked-rabbitmq.jpg)

When more nodes are published into the queue they become blocked behind the unacked message.

![acl queue blocked rabbitmq1](../_images/advanced-config/acl-queue-blocked-rabbitmq1.jpg)

There are two ways to solve this:

1.  Recreate the node on the public instance and restart the consumer.

    1.  The sequence number count remains correct.

    2.  You have to connect to the public instance and do "manual manipulation".


2.  Remove the faulty activation message from the queue and restart the consumer.

    1.  This can be done remotely and there is no need to connect "manually" to the public instance.

    2.  Because there is one "missing" message the sequence number is lost.



Hereâ€™s a step-by-step solution using option 2 (because it demonstrates how to delete an unacknowledged message):

1.  Close the channel in the RabbitMQ console. This acknowledges all unacknowledged messages and is needed because messages can no longer be consumed.

    ![close channel](../_images/advanced-config/close-channel.jpg)

2.  Force close the connection

    ![force close connection](../_images/advanced-config/force-close-connection.jpg)

3.  All messages are now acked in the queue.

    ![messages acked](../_images/advanced-config/messages-acked.jpg)

4.  Consume only the "first" message.

    ![consume 1st message](../_images/advanced-config/consume-1st-message.jpg)

    ![consume 1st message1](../_images/advanced-config/consume-1st-message1.jpg)

5.  Restart the consumer on the public instance.

    ```sh
    curl http://<hostname>:<port>/<context>/.rest/rbmqClients/restartAll
    ```

6.  The instance is getting activated again.

    ![close channel](../_images/advanced-config/close-channel.jpg)
