---
title: "Customization"
url: https://docs.magnolia-cms.com/ai-accelerator/4.0-alpha/developers/vector-db/customization/
category: Modules
version: modules
breadcrumb: AI Accelerator module > Customization
---

# Customization

## [](#_overview)Overview

The Vector Database integration is designed to be extensible. You can customize:

-   **Content Extractors**: How content is extracted from JCR nodes

-   **Embedding Providers**: How embeddings are generated

-   **Security Filters**: How permissions are applied

-   **Search Ranking**: How results are scored and ranked

-   **Metadata**: What metadata is indexed with content


## [](#_custom_content_extractors)Custom content extractors

Create custom extractors for specialized content types using the registry-based approach.

### [](#_creating_custom_extractor_definitions)Creating custom extractor definitions

Since version 4.1, extractors use a registry-based approach with the `@ExtractorType` annotation. This allows you to create custom extractor types that can be configured via YAML.

#### [](#_create_extractor_definition)Create extractor definition

Create a class that extends `ExtractorDefinition` and add the `@ExtractorType` annotation:

```java
package com.example.extractors;

import info.magnolia.ai.context.observation.ExtractorDefinition;
import info.magnolia.ai.context.observation.ExtractorType;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@ExtractorType("product") (1)
public class ProductExtractorDefinition extends ExtractorDefinition {

    /**
     * Whether to include product specifications in the indexed content.
     */
    private boolean includeSpecifications = true;

    /**
     * Whether to include customer reviews in the indexed content.
     */
    private boolean includeReviews = true;

    /**
     * Maximum number of reviews to include (0 = unlimited).
     */
    private int maxReviews = 10;

    /**
     * Whether to include pricing information.
     */
    private boolean includePricing = true;
}
```

|     |     |
| --- | --- |
| **1** | The `@ExtractorType` annotation registers this definition with type name "product" |

#### [](#_configure_in_yaml)Configure in YAML

Use your custom extractor in the configuration:

```yaml
indexing:
  workspaces:
    products:
      enabled: true
      workspace: products
      extractor:
        $type: product (1)
        includeSpecifications: true
        includeReviews: true
        maxReviews: 5
        includePricing: false
      nodeTypes: [mgnl:product]
```

|     |     |
| --- | --- |
| **1** | The `$type` value matches the `@ExtractorType` annotation |

#### [](#_implement_content_extractor)Implement content extractor

Create the actual extractor implementation that uses your definition:

```java
package com.example.extractors;

import info.magnolia.ai.interfaces.vectordb.ContentDocument;
import info.magnolia.ai.context.extractor.ContentExtractor;
import info.magnolia.ai.context.observation.ExtractorDefinition;
import info.magnolia.jcr.util.PropertyUtil;

import javax.jcr.Node;
import javax.jcr.NodeIterator;
import javax.jcr.RepositoryException;
import jakarta.inject.Singleton;

@Singleton
public class ProductDocumentExtractor implements ContentExtractor {

    @Override
    public boolean canExtract(Node node) throws RepositoryException {
        return node.isNodeType("mgnl:product");
    }

    @Override
    public ContentDocument extract(Node node, String language)
            throws RepositoryException {
        return extract(node, language, null);
    }

    @Override
    public ContentDocument extract(Node node, String language, ExtractorDefinition definition)
            throws RepositoryException {

        // Cast to specific definition type
        ProductExtractorDefinition config = (ProductExtractorDefinition) definition;

        ContentDocument.Builder builder = ContentDocument.builder()
                .id("magnolia:" + node.getWorkspace().getName() + node.getPath())
                .workspace(node.getWorkspace().getName())
                .path(node.getPath())
                .language(language);

        // Extract basic product info
        String name = PropertyUtil.getString(node, "name");
        String description = PropertyUtil.getString(node, "description");

        StringBuilder content = new StringBuilder();
        content.append(name).append(". ");
        content.append(description).append(". ");

        // Conditionally include pricing
        if (config != null && config.isIncludePricing()) {
            Double price = PropertyUtil.getDouble(node, "price");
            if (price != null) {
                content.append("Price: $").append(price).append(". ");
            }
        }

        // Conditionally include specifications
        if (config != null && config.isIncludeSpecifications()) {
            if (node.hasNode("specifications")) {
                Node specs = node.getNode("specifications");
                NodeIterator specItems = specs.getNodes();

                while (specItems.hasNext()) {
                    Node spec = specItems.nextNode();
                    String key = PropertyUtil.getString(spec, "key");
                    String value = PropertyUtil.getString(spec, "value");
                    content.append(key).append(": ").append(value).append(". ");
                }
            }
        }

        // Conditionally include reviews
        if (config != null && config.isIncludeReviews()) {
            if (node.hasNode("reviews")) {
                Node reviews = node.getNode("reviews");
                NodeIterator reviewItems = reviews.getNodes();

                int count = 0;
                int maxReviews = config.getMaxReviews();

                while (reviewItems.hasNext() && (maxReviews == 0 || count < maxReviews)) {
                    Node review = reviewItems.nextNode();
                    String reviewText = PropertyUtil.getString(review, "comment");
                    if (reviewText != null) {
                        content.append("Review: ").append(reviewText).append(". ");
                        count++;
                    }
                }
            }
        }

        builder.content(content.toString());

        // Add metadata
        builder.addMetadata("nodeType", node.getPrimaryNodeType().getName());
        builder.addMetadata("sku", PropertyUtil.getString(node, "sku"));
        if (config != null && config.isIncludePricing()) {
            builder.addMetadata("price", PropertyUtil.getString(node, "price"));
        }

        return builder.build();
    }
}
```

#### [](#_register_extractor_optional)Register extractor (optional)

If using custom Guice binding, register your extractor:

```java
public class CustomExtractorsModule extends AbstractModule {
    @Override
    protected void configure() {
        bind(ContentExtractor.class)
            .annotatedWith(Names.named("product"))
            .to(ProductDocumentExtractor.class);
    }
}
```

### [](#_extractor_interface)Extractor interface

```java
public interface ContentExtractor {
    /**
     * Extract content from a JCR node.
     *
     * @param node JCR node to extract from
     * @param language Language to extract (for i18n content)
     * @return Extracted content document
     */
    ContentDocument extract(Node node, String language) throws RepositoryException;

    /**
     * Check if this extractor can handle the given node.
     */
    boolean canExtract(Node node) throws RepositoryException;
}
```

### [](#_example_custom_product_extractor)Example: Custom product extractor

```java
package com.example.extractors;

import info.magnolia.ai.interfaces.vectordb.ContentDocument;
import info.magnolia.ai.context.extractor.ContentExtractor;
import info.magnolia.jcr.util.PropertyUtil;

import javax.jcr.Node;
import javax.jcr.NodeIterator;
import javax.jcr.RepositoryException;

/**
 * Extracts product data including specifications and reviews.
 */
public class ProductDocumentExtractor implements ContentExtractor {

    @Override
    public boolean canExtract(Node node) throws RepositoryException {
        return node.isNodeType("mgnl:product"); (1)
    }

    @Override
    public ContentDocument extract(Node node, String language)
            throws RepositoryException {

        ContentDocument.Builder builder = ContentDocument.builder()
                .id("magnolia:" + node.getWorkspace().getName() + node.getPath())
                .workspace(node.getWorkspace().getName())
                .path(node.getPath());

        // Extract basic product info
        String name = PropertyUtil.getString(node, "name");
        String description = PropertyUtil.getString(node, "description");
        Double price = PropertyUtil.getDouble(node, "price");
        String sku = PropertyUtil.getString(node, "sku");

        // Build searchable content
        StringBuilder content = new StringBuilder();
        content.append(name).append(". ");
        content.append(description).append(". ");
        content.append("Price: $").append(price).append(". ");

        // Extract specifications
        if (node.hasNode("specifications")) { (2)
            Node specs = node.getNode("specifications");
            NodeIterator specItems = specs.getNodes();

            while (specItems.hasNext()) {
                Node spec = specItems.nextNode();
                String key = PropertyUtil.getString(spec, "key");
                String value = PropertyUtil.getString(spec, "value");
                content.append(key).append(": ").append(value).append(". ");
            }
        }

        // Extract and summarize reviews
        if (node.hasNode("reviews")) { (3)
            Node reviews = node.getNode("reviews");
            long reviewCount = reviews.getNodes().getSize();
            content.append(reviewCount).append(" customer reviews. ");

            // Add review highlights
            NodeIterator reviewItems = reviews.getNodes();
            while (reviewItems.hasNext()) {
                Node review = reviewItems.nextNode();
                String reviewText = PropertyUtil.getString(review, "text");
                if (reviewText != null && reviewText.length() > 100) {
                    content.append(reviewText.substring(0, 100)).append("... ");
                }
            }
        }

        builder.content(content.toString());

        // Add metadata
        builder.metadata("sku", sku)
               .metadata("price", price)
               .metadata("language", language)
               .metadata("nodeType", node.getPrimaryNodeType().getName())
               .metadata("indexedAt", System.currentTimeMillis())
               .metadata("mimeType", "application/vnd.magnolia.product+json");

        // Add custom product metadata
        if (node.hasProperty("category")) {
            builder.metadata("category", PropertyUtil.getString(node, "category"));
        }

        if (node.hasProperty("brand")) {
            builder.metadata("brand", PropertyUtil.getString(node, "brand"));
        }

        if (node.hasProperty("inStock")) {
            builder.metadata("inStock", PropertyUtil.getBoolean(node, "inStock", false));
        }

        return builder.build();
    }
}
```

|     |     |
| --- | --- |
| **1** | Only extract nodes of type `mgnl:product` |
| **2** | Extract product specifications as key-value pairs |
| **3** | Include review content for better search results |

### [](#_register_custom_extractor)Register custom extractor

Create a Guice module to register your extractor:

```java
package com.example.extractors;

import com.google.inject.AbstractModule;
import com.google.inject.multibindings.Multibinder;
import info.magnolia.ai.context.extractor.ContentExtractor;

public class CustomExtractorsModule extends AbstractModule {

    @Override
    protected void configure() {
        Multibinder<ContentExtractor> extractorBinder =
                Multibinder.newSetBinder(binder(), ContentExtractor.class);

        extractorBinder.addBinding().to(ProductDocumentExtractor.class); (1)
    }
}
```

|     |     |
| --- | --- |
| **1** | Register custom extractor |

Register the Guice module in your module descriptor:

```java
package com.example;

import info.magnolia.module.ModuleLifecycle;
import info.magnolia.module.ModuleLifecycleContext;
import com.google.inject.Module;

import java.util.ArrayList;
import java.util.List;

public class CustomVectorDbModule implements ModuleLifecycle {

    public List<Module> configure() { (1)
        List<Module> modules = new ArrayList<>();
        modules.add(new CustomExtractorsModule());
        return modules;
    }

    @Override
    public void start(ModuleLifecycleContext moduleLifecycleContext) {
        // Module startup logic
    }

    @Override
    public void stop(ModuleLifecycleContext moduleLifecycleContext) {
        // Module shutdown logic
    }
}
```

|     |     |
| --- | --- |
| **1** | Return list of Guice modules to register |

### [](#_use_custom_extractor)Use custom extractor

Configure your workspace to use the custom extractor:

```yaml
indexing:
  workspaces:
    products:
      enabled: true
      workspace: products
      extractor: CONTENT (1)
      nodeTypes: [mgnl:product]
```

|     |     |
| --- | --- |
| **1** | The system will automatically detect and use `ProductDocumentExtractor` for `mgnl:product` nodes |

## [](#_custom_metadata_fields)Custom metadata fields

Add custom metadata to all indexed documents.

### [](#_metadata_enrichment)Metadata enrichment

```java
package com.example.enrichment;

import info.magnolia.ai.interfaces.vectordb.ContentDocument;
import info.magnolia.jcr.util.PropertyUtil;

import java.util.Arrays;
import java.util.Calendar;
import javax.jcr.Node;
import javax.jcr.RepositoryException;

/**
 * Enriches content documents with custom metadata.
 */
public class CustomMetadataEnricher {

    public ContentDocument enrich(ContentDocument doc, Node node)
            throws RepositoryException {

        ContentDocument.Builder builder = doc.toBuilder();

        // Add publication status
        if (node.hasProperty("published")) {
            boolean published = PropertyUtil.getBoolean(node, "published", false);
            builder.metadata("published", published);

            if (published && node.hasProperty("publicationDate")) {
                Calendar pubDate = PropertyUtil.getDate(node, "publicationDate");
                builder.metadata("publicationDate", pubDate.getTimeInMillis());
            }
        }

        // Add workflow state
        if (node.hasProperty("workflowState")) {
            String state = PropertyUtil.getString(node, "workflowState");
            builder.metadata("workflowState", state);
        }

        // Add author information
        if (node.hasProperty("mgnl:createdBy")) {
            String author = PropertyUtil.getString(node, "mgnl:createdBy");
            builder.metadata("author", author);
        }

        // Add tags/categories
        if (node.hasProperty("tags")) {
            String[] tags = PropertyUtil.getStrings(node, "tags");
            builder.metadata("tags", Arrays.asList(tags));
        }

        // Add performance metrics (if available)
        if (node.hasProperty("pageViews")) {
            Long views = PropertyUtil.getLong(node, "pageViews");
            builder.metadata("pageViews", views);
        }

        return builder.build();
    }
}
```

### [](#_integrate_enrichment)Integrate enrichment

Extend an existing extractor to include enrichment:

```java
package com.example.extractors;

import info.magnolia.ai.context.extractor.PageDocumentExtractor;
import info.magnolia.ai.interfaces.vectordb.ContentDocument;
import com.example.enrichment.CustomMetadataEnricher;

import javax.jcr.Node;
import javax.jcr.RepositoryException;
import jakarta.inject.Singleton;

@Singleton

public class EnrichedPageExtractor extends PageDocumentExtractor {

    private final CustomMetadataEnricher enricher = new CustomMetadataEnricher();

    @Override
    public ContentDocument extract(Node node, String language)
            throws RepositoryException {

        // Extract base content
        ContentDocument baseDoc = super.extract(node, language);

        // Enrich with custom metadata
        return enricher.enrich(baseDoc, node);
    }
}
```

## [](#_custom_search_ranking)Custom search ranking

Customize how search results are ranked.

### [](#_custom_reranking_service)Custom reranking service

```java
package com.example.search;

import info.magnolia.ai.context.service.RerankingService;
import info.magnolia.ai.interfaces.vectordb.VectorSearchResult;

import java.util.List;
import java.util.stream.Collectors;
import jakarta.inject.Singleton;

@Singleton

/**
 * Custom reranking with business rules.
 */
public class CustomRerankingService implements RerankingService {

    @Override
    public List<VectorSearchResult> rerank(List<VectorSearchResult> results, String query) {
        return results.stream()
                .map(result -> {
                    double score = result.getScore();

                    // Boost recently published content
                    if (result.getMetadata().containsKey("publicationDate")) {
                        long pubDate = (Long) result.getMetadata().get("publicationDate");
                        long ageInDays = (System.currentTimeMillis() - pubDate) / (1000 * 60 * 60 * 24);

                        if (ageInDays < 30) {
                            score *= 1.2; // 20% boost for content < 30 days old
                        }
                    }

                    // Boost published over draft content
                    if (Boolean.TRUE.equals(result.getMetadata().get("published"))) {
                        score *= 1.15; // 15% boost for published content
                    }

                    // Boost high-traffic pages
                    if (result.getMetadata().containsKey("pageViews")) {
                        Long views = (Long) result.getMetadata().get("pageViews");
                        if (views > 10000) {
                            score *= 1.1; // 10% boost for popular pages
                        }
                    }

                    // Boost exact title matches
                    String title = (String) result.getMetadata().get("title");
                    if (title != null && title.toLowerCase().contains(query.toLowerCase())) {
                        score *= 1.25; // 25% boost for title matches
                    }

                    result.setScore(score);
                    return result;
                })
                .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
                .collect(Collectors.toList());
    }
}
```

### [](#_register_custom_reranking)Register custom reranking

```java
package com.example;

import com.google.inject.AbstractModule;
import info.magnolia.ai.context.service.RerankingService;
import com.example.search.CustomRerankingService;

public class CustomSearchModule extends AbstractModule {

    @Override
    protected void configure() {
        bind(RerankingService.class).to(CustomRerankingService.class); (1)
    }
}
```

|     |     |
| --- | --- |
| **1** | Replace default reranking service with custom implementation |

## [](#_custom_security_filters)Custom security filters

Extend the security model with custom filtering logic.

### [](#_custom_permission_extractor)Custom permission extractor

```java
package com.example.security;

import info.magnolia.ai.context.service.UserPermissionService;
import info.magnolia.ai.interfaces.vectordb.VectorSearchResult;
import info.magnolia.cms.security.User;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import jakarta.inject.Singleton;

@Singleton

/**
 * Custom permission extraction with business rules.
 */
public class CustomPermissionService extends UserPermissionService {

    @Override
    public List<String> getAllowedPaths(User user, List<String> workspaces) {
        List<String> patterns = super.getAllowedPaths(user, workspaces);

        // Add custom permission logic
        if (user.hasRole("premium-member")) {
            patterns.add("/premium/*"); (1)
        }

        if (user.hasRole("subscriber")) {
            patterns.add("/subscribers-only/*"); (2)
        }

        // Filter based on user metadata
        String department = (String) user.getProperty("department");
        if ("marketing".equals(department)) {
            patterns.add("/marketing/*"); (3)
        }

        return patterns;
    }

    /**
     * Custom post-filtering logic.
     */
    public List<VectorSearchResult> postFilter(List<VectorSearchResult> results, User user) {
        return results.stream()
                .filter(result -> {
                    // Filter based on publication status for non-admin users
                    if (!user.hasRole("admin")) {
                        Boolean published = (Boolean) result.getMetadata().get("published");
                        if (Boolean.FALSE.equals(published)) {
                            return false; // Hide unpublished from non-admins
                        }
                    }

                    // Filter based on workflow state
                    String state = (String) result.getMetadata().get("workflowState");
                    if ("archived".equals(state) && !user.hasRole("archivist")) {
                        return false; // Hide archived from non-archivists
                    }

                    return true;
                })
                .collect(Collectors.toList());
    }
}
```

|     |     |
| --- | --- |
| **1** | Grant access to premium content for premium members |
| **2** | Grant access to subscriber content |
| **3** | Grant department-specific access |

## [](#_custom_embedding_provider)Custom embedding provider

Create a custom embedding provider for specialized use cases.

### [](#_provider_implementation)Provider implementation

```java
package com.example.embeddings;

import info.magnolia.ai.interfaces.vectordb.EmbeddingProvider;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import jakarta.inject.Singleton;

@Singleton

/**
 * Custom embedding provider using a local model server.
 */
public class CustomEmbeddingProvider implements EmbeddingProvider {

    private final String serverUrl;
    private final HttpClient httpClient;

    public CustomEmbeddingProvider(String serverUrl) {
        this.serverUrl = serverUrl;
        this.httpClient = HttpClient.newHttpClient();
    }

    @Override
    public float[] embed(String text) {
        try {
            // Call custom embedding service
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverUrl + "/embeddings"))
                    .header("Content-Type", "application/json")
                    .POST(HttpRequest.BodyPublishers.ofString(
                            "{\"text\": \"" + escapeJson(text) + "\"}"))
                    .build();

            HttpResponse<String> response = httpClient.send(request,
                    HttpResponse.BodyHandlers.ofString());

            // Parse response
            JsonObject json = JsonParser.parseString(response.body()).getAsJsonObject();
            JsonArray embedding = json.getAsJsonArray("embedding");

            float[] result = new float[embedding.size()];
            for (int i = 0; i < embedding.size(); i++) {
                result[i] = embedding.get(i).getAsFloat();
            }

            return result;

        } catch (Exception e) {
            throw new RuntimeException("Failed to generate embedding", e);
        }
    }

    @Override
    public int getDimension() {
        return 768; // Model-specific dimension
    }

    @Override
    public String getModelId() {
        return "custom-embedding-model-v1";
    }

    @Override
    public boolean isReady() {
        try {
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverUrl + "/health"))
                    .GET()
                    .build();

            HttpResponse<String> response = httpClient.send(request,
                    HttpResponse.BodyHandlers.ofString());

            return response.statusCode() == 200;
        } catch (Exception e) {
            return false;
        }
    }

    private String escapeJson(String text) {
        return text.replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r");
    }
}
```

### [](#_register_custom_provider)Register custom provider

```java
package com.example;

import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import info.magnolia.ai.interfaces.vectordb.EmbeddingProvider;
import com.example.embeddings.CustomEmbeddingProvider;

public class CustomEmbeddingModule extends AbstractModule {

    @Provides
    public EmbeddingProvider provideEmbeddingProvider() {
        String serverUrl = System.getenv("EMBEDDING_SERVER_URL");
        if (serverUrl == null) {
            serverUrl = "http://localhost:8001";
        }
        return new CustomEmbeddingProvider(serverUrl);
    }
}
```

## [](#_advanced_configuration)Advanced configuration

### [](#_dynamic_configuration)Dynamic configuration

Load configuration from external sources:

```java
package com.example.config;

import info.magnolia.ai.context.observation.ObservationIndexingConfig;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

/**
 * Dynamically load indexing configuration from database or external service.
 */
public class DynamicIndexingConfigProvider {

    public ObservationIndexingConfig getConfig() {
        // Load from database, REST API, or config server
        String configJson = fetchFromConfigServer();

        // Parse and return config
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(configJson, ObservationIndexingConfig.class);
    }

    private String fetchFromConfigServer() {
        // Call external config service
        HttpResponse<String> response = httpClient.send(
                HttpRequest.newBuilder()
                        .uri(URI.create("https://config.example.com/vector-db"))
                        .GET()
                        .build(),
                HttpResponse.BodyHandlers.ofString());

        return response.body();
    }
}
```

### [](#_environment_specific_extractors)Environment-specific extractors

Use different extractors based on environment:

```java
package com.example.extractors;

import info.magnolia.ai.context.extractor.ContentExtractor;
import info.magnolia.ai.interfaces.vectordb.ContentDocument;

import javax.jcr.Node;
import javax.jcr.RepositoryException;

public class EnvironmentAwareExtractor implements ContentExtractor {

    private final ContentExtractor delegate;

    public EnvironmentAwareExtractor() {
        String env = System.getenv("MAGNOLIA_ENV");

        if ("prod".equals(env)) {
            delegate = new ProductionExtractor(); (1)
        } else {
            delegate = new DevelopmentExtractor(); (2)
        }
    }

    @Override
    public ContentDocument extract(Node node, String language) throws RepositoryException {
        return delegate.extract(node, language);
    }

    @Override
    public boolean canExtract(Node node) throws RepositoryException {
        return delegate.canExtract(node);
    }
}
```

|     |     |
| --- | --- |
| **1** | Use production extractor (minimal metadata, optimized) |
| **2** | Use development extractor (verbose metadata, debugging info) |

## [](#_testing_custom_components)Testing custom components

### [](#_unit_testing_extractors)Unit testing extractors

```java
package com.example.extractors;

import info.magnolia.ai.interfaces.vectordb.ContentDocument;
import org.junit.jupiter.api.Test;

import javax.jcr.Node;
import javax.jcr.Property;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ProductDocumentExtractorTest {

    @Test
    void testExtract() throws Exception {
        // Create mock node
        Node node = mock(Node.class);
        Property nameProp = mock(Property.class);
        Property priceProp = mock(Property.class);

        when(node.isNodeType("mgnl:product")).thenReturn(true);
        when(node.getPath()).thenReturn("/products/laptop");
        when(node.hasProperty("name")).thenReturn(true);
        when(node.hasProperty("price")).thenReturn(true);
        when(node.getProperty("name")).thenReturn(nameProp);
        when(node.getProperty("price")).thenReturn(priceProp);
        when(nameProp.getString()).thenReturn("Gaming Laptop");
        when(priceProp.getDouble()).thenReturn(1299.99);

        // Test extraction
        ProductDocumentExtractor extractor = new ProductDocumentExtractor();
        ContentDocument doc = extractor.extract(node, "en");

        assertNotNull(doc);
        assertTrue(doc.getContent().contains("Gaming Laptop"));
        assertEquals(1299.99, doc.getMetadata().get("price"));
    }
}
```

### [](#_integration_testing)Integration testing

```java
package com.example.integration;

import info.magnolia.ai.interfaces.vectordb.VectorSearchResult;
import info.magnolia.test.RepositoryTestCase;
import org.junit.jupiter.api.Test;

import javax.jcr.Node;
import javax.jcr.Session;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class VectorDbIntegrationTest extends RepositoryTestCase {

    @Test
    void testIndexingAndSearch() throws Exception {
        Session session = getSession();

        // Create test content
        Node testNode = session.getRootNode().addNode("test-product", "mgnl:product");
        testNode.setProperty("name", "Test Product");
        testNode.setProperty("description", "A test product for integration testing");
        session.save();

        // Trigger indexing (assuming indexingService is injected)
        // indexingService.indexNode(testNode, "en");

        // Wait for async indexing
        Thread.sleep(2000);

        // Search for content (assuming searchService is injected)
        // List<VectorSearchResult> results = searchService.search("test product", List.of("products"), 10);

        // Verify results
        // assertFalse(results.isEmpty());
        // assertEquals("/test-product", results.get(0).getMetadata().get("path"));
    }
}
```

## [](#_best_practices)Best practices

1.  **Keep extractors focused**: Each extractor should handle one content type

2.  **Use metadata strategically**: Only index metadata youâ€™ll actually filter/search by

3.  **Test thoroughly**: Write unit and integration tests for custom components

4.  **Monitor performance**: Track extraction and embedding generation times

5.  **Document customizations**: Document why customizations were needed and how they work

6.  **Version carefully**: Custom components may break with module updates


## [](#_next_steps)Next steps

-   [Index content with custom extractors](../indexing/)

-   [Test custom search ranking](../search/)

-   [Learn about AI Accelerator plugin system](../../plugins/)
