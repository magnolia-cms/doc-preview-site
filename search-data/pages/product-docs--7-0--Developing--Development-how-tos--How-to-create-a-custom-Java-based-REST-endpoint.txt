---
title: "How to create a custom Java-based REST endpoint"
url: https://docs.magnolia-cms.com/product-docs/7.0/Developing/Development-how-tos/How-to-create-a-custom-Java-based-REST-endpoint/
category: Magnolia 6.4
version: latest
breadcrumb: DX Core > Developing > Development how-tos > How to create a custom Java-based REST endpoint
---

# How to create a custom Java-based REST endpoint

This page provides guidelines and best practice recommendations on how to create a custom Java-based REST endpoint with Magnolia.

Java-based custom REST endpoints give access to the full power of Java and provide a high level of flexibility and configurability. REST endpoints in Magnolia also allow fine-grained security.

Endpoints can be used for many purposes, from triggering a third party service to implementing a custom JSON provider. However, there are also other possibilities to [get Magnolia content as JSON](../How-to-get-content-as-JSON-an-overview/).

In this page, we assume that you know Java and the basics of Maven or another similar dependency management tool.

| Data interaction function | Read data | Create data | Update data | Delete data |
| --- | --- | --- | --- | --- |
| HTTP Method | `GET` | `PUT` | `POST` | `DELETE` |
| Request has payload | no | yes | yes | no |
| Response has payload | yes | maybe | maybe | no |

## [](#_java_maven_and_package_names)Java, Maven and package names

Java classes typically are wrapped in modules. When the Java classes of your endpoint are part of a (Maven) module, you can add the module to your [bundle or webapp](../../Bundles-and-webapps/) as a .jar file or manage the dependency with Maven in the POM file of the webapp.

Wrap your Java REST endpoint within a Magnolia Maven module.

### [](#_creating_a_magnolia_maven_module_with_a_maven_archetype)Creating a Magnolia Maven module with a Maven archetype

Use the Magnolia Maven archetype to create a new Magnolia Maven module that will host your Java REST endpoint.

If you are not familiar with the Maven archetype plugin, please read [How to use Magnolia Maven archetypes: The archetype plugin](../How-to-use-Magnolia-Maven-archetypes/#_the_archetype_plugin).

Here is the archetype command call:

mvn archetype:generate -DarchetypeGroupId=info.magnolia.maven.archetypes -DarchetypeArtifactId=magnolia-module-archetype -DarchetypeVersion=RELEASE

> **Note:** Always use the latest version of the archetype.Provide meaningful values for the groupId and artifactId.Provide the magnolia-bundle-version that fits your existing Magnolia bundle(s) best. If you are not sure, use the latest released Magnolia version: 7.0.0The archetype creates a POM file which imports the magnolia-bundle-parent. This parent manages the versions of Magnolia modules you rely on.

### [](#_java_package_name)Java package name

Add the Java class, which represents the REST resource, to a package with a name that allows versioning of the REST resource. Typically, the last part of the package name should indicate the version.

com.example.rest.service.v1.DemoEndpoint

```java
package com.example.rest.service.v1;

@Path("/demo/v1")
public class DemoEndpoint {
  /* more code to be added here later on */
}
```

In this example:

-   The package name is `com.example.rest.service.`**`v1`**.

-   The class name is `DemoEndpoint`.

-   The fully qualified class name (fqcn) is `com.example.rest.service.v1.DemoEndpoint`.


If you want to raise the version of the endpoint later on, without disabling the original version, create a package with a higher version such as `com.example.rest.service.`**`v2`**.

## [](#_magnolia_rest_modules_and_recommended_dependencies)Magnolia REST modules and recommended dependencies

We assume that you know the basics about how to manage dependencies, and that you manage these dependencies with Maven.

The [Java API for RESTful Web Services - JAX-RS](https://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services) is defined in the `jakarta.ws.rs` package and its subpackages, such as `jakarta.ws.rs.core` and `jakarta.ws.rs.ext`.

These are interfaces and sufficient for endpoint classes during compilation. However, on runtime, when the REST resources are used, a webapp also requires implementations of the these two mentioned packages. Magnolia uses [RESTeasy](http://resteasy.jboss.org/) for this purpose.

The dependencies (for both the interfaces and the implementations) are managed by the `magnolia-rest-integration` module.

Magnolia’s REST web services consist of several modules:

-   REST Services

-   REST Integration

-   REST Content Delivery

-   REST Tools


Depend on the [Magnolia REST modules](../../../../../rest/). This ensures that you use the same versions of JAX-RS interfaces and implementation libraries as Magnolia.

You should at least depend on the `magnolia-rest-integration` module.

Your module, which depends on Magnolia REST module(s), automatically (transiently) inherits the dependencies from the Magnolia modules.

The Magnolia REST module contains three submodules.

### [](#_magnolia_rest_modules)Magnolia REST modules

#### [](#_magnolia_rest_integration)`magnolia-rest-integration`

The REST Tools module integrates the [swagger tools](https://swagger.io/tools/) into the Admin UI. These tools ease the development and testing of REST endpoints.

The module extends the `RestDispatcherServlet` with a custom, API-aware servlet that can read API annotations from all available REST endpoints. The servlet enables the endpoints in the Swagger API explorer. If you write your own endpoint you need to add annotations in the code yourself.

> **Caution:** This is installed by default.

#### [](#_magnolia_rest_services)`magnolia-rest-services`

The `magnolia-rest-services` module depends on the `magnolia-rest-integration` module. Therefore, it provides everything explained in the previous section.

In addition, it contains the default Magnolia REST endpoints info.magnolia.rest.service.node.v1.NodeEndpoint, info.magnolia.rest.service.property.v1.PropertyEndpoint and info.magnolia.rest.service.command.v1.CommandEndpoint, which are described on the [Delivery API](../../../../../rest/api/delivery-endpoint/) page.

This module also provides info.magnolia.rest.service.node.v1.RepositoryMarshaller, which [you can use](#_about_marshalling_and_data_conversion) within your custom endpoint.

#### [](#_magnolia_rest_content_delivery)`magnolia-rest-content-delivery`

This module provides the [Delivery endpoint](../../../../../rest/api/delivery-endpoint/).

#### [](#_magnolia_rest_tools)`magnolia-rest-tools`

The REST Tools module integrates the [swagger tools](https://swagger.io/tools/) into the Admin UI. These tools ease the development and testing of REST endpoints.

The module extends the `RestDispatcherServlet` with a custom, API-aware servlet that can read API annotations from all available REST endpoints. The servlet enables the endpoints in the Swagger API explorer. If you write your own endpoint you need to add annotations in the code yourself.

> **Caution:** This is installed by default.

The module is used for development and testing purposes only.

#### [](#_magnolia_rest_module_versions)Magnolia REST module versions

Make sure you use the same version for all Magnolia REST modules on which you depend.

The version of the Magnolia REST modules depends on the version of Magnolia you use to run your custom endpoint. We recommend you check the POM file (or the parent POM file) of your Magnolia webapp. The .pom file manages the version of the Magnolia REST modules using the property `restVersion`. If you are unsure, use the latest released version, which is currently: {magnolia-rest-64}

| Property | Description |
| --- | --- |
| `restEndpoints` | **required** The folder which contains a list of endpoint definitions. The name of the folder must be `restEndpoints` . |
| `<endpoint-name>` | **required** The name of the endpoint. The name is arbitrary but must be unique. |
| `class` | **required** The fully qualified class name of the definition class. Typically `info.magnolia.rest.EndpointDefinition` or a subclass. |
| `implementationClass` | **required** The fully qualified class name of the REST endpoint java class. |

## [](#_about_marshalling_and_data_conversion)About marshalling and data conversion

An endpoint dealing with data must manage two types of data conversion:

-   Transforming data into a simple Java bean or [POJO](https://en.wikipedia.org/wiki/Plain_old_Java_object) (Plain Old Java Object) and vice versa.

-   Transforming the POJO into JSON or XML and vice versa.


If the endpoint handles both read (GET) and write (PUT to create and POST to update) actions, marshalling and data conversion must also work in both directions.

In this section we focus on some aspects of this kind of data conversion.

![Data transformation diagram](../../../../RNs-6-4-3/_images/data-transformation.png)

### [](#_converting_a_data_object_into_a_pojo_and_vice_versa)Converting a data object into a POJO and vice versa

Regardless of the type of data you deal with, in the context of a REST endpoint, at some point you typically transform data into a POJO (and vice versa).

There is no one size fits all for transforming a data object into a POJO and vice versa. The best solution for you depends on your use case.

#### [](#_jcr_to_pojo)JCR to POJO

The `magnolia-rest-services` module provides classes to transform JCR nodes and properties into POJOs and vice versa.

-   info.magnolia.rest.service.node.v1.RepositoryMarshaller is the transformer.

-   info.magnolia.rest.service.node.v1.RepositoryNode is the type of the POJO.


The Magnolia endpoints info.magnolia.rest.service.property.v1.PropertyEndpoint and info.magnolia.rest.service.node.v1.NodeEndpoint use these classes. You also can use the classes for your custom endpoints. However, note that the structure of the POJO and of the resulting payload after marshalling may *not* cover your requirements.

### [](#_marshalling_and_unmarshalling_creating_and_receiving_payload)Marshalling and unmarshalling - creating and receiving payload

Transforming a POJO into JSON or XML is known as [marshalling](https://en.wikipedia.org/wiki/Marshalling_%28computer_science%29). Transforming JSON or XML into a POJO is known as [unmarshalling](https://en.wikipedia.org/wiki/Unmarshalling). Both processes are sometimes referred to as marshalling.

Marshalling is handled by the REST framework by the [JAX-RS API](https://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services) implementation.

However, when dealing with payload (XML or JSON) in your endpoint, note the following:

-   To create payload, you must `PUT` a POJO into the response of the endpoint method.

-   When receiving payload from a request, the responsible method must have an appropriate signature in order to initiate unmarshalling.


#### [](#_adding_pojos_to_the_rest_response_to_deliver_payload)Adding POJOs to the REST response to deliver payload

Imagine you have a POJO with the name `Lunch` and two properties: `food` and `beverage`.

com.example.rest.pojos.Lunch

[java/com/example/rest/pojos/Lunch.java]({repo-demoRestServices})

Now you require a method which can deliver a `lunch` payload. Endpoint method(s) providing a `Lunch` object would look like this:

```java
    @Path("/lunch2")
    @GET
    @Produces({MediaType.APPLICATION_JSON})
    public Response lunch2() {
        Lunch pojo = new Lunch("Rösti mit Geschnetzeltem", "Ueli Weizen");
        return Response.ok(pojo).build();
    }

    @Path("/lunch")
    @GET
    @Produces({MediaType.APPLICATION_JSON})
    public Lunch lunch() {
        Lunch pojo = new Lunch("Svíčková na smetaně ", "Gambrinus Plzen");
        return pojo;
    }
```

> **Note:** The seeming parallelism between new Lunch("Rösti mit Geschnetzeltem", "Ueli Weizen"); and new Lunch("Svíčková na smetaně ", "Gambrinus Plzen"); is no way intended to present how to handle internationalization.

The snippet shows two methods: `#lunch` and `#lunch2`. Both produce the same payload when called from outside, however, their implementation is slightly different.

`#lunch2`

-   Uses the generic return type `jakarta.ws.rs.core.Response`.

-   Puts the POJO (of the type `Lunch`) into this response; see line 6.

-   This approach provides high flexibility concerning the response code, for instance you can do things like this:

    ```java
    return Response.status(Response.Status.NOT_ACCEPTABLE).build();
    //...
    return Response.status(Response.Status.BAD_REQUEST).build();
    ```


`#lunch`

-   Uses the specific POJO as return type. Here it is `com.example.rest.pojos.Lunch`.

-   Returns the POJO directly on the method.


Note that both method produce the same response headers and identical payload (structure, in this example only the values of the food and beverage properties differ).

`#lunch2`

curl -i --user superuser:superuser -X GET --header 'Accept: application/json' 'http://localhost:8080/magnoliaAuthor/.rest/demo/v1/lunch2'
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=427FFB4FD60492BDD7D8C76E28F91222; Path=/magnoliaAuthor/; HttpOnly
Pragma: no-cache
Cache-Control: no-cache, no-store, must-revalidate, max-age=0
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Type: application/json;charset=UTF-8
Content-Length: 61
Date: Wed, 05 Jul 2017 16:48:53 GMT

{"id":"b8a3da44-35cf-48a5-9f69-dc38bff881da","food":"Rösti mit Geschnetzeltem","beverage":"Ueli Weizen"}

`#lunch`

curl -i --user superuser:superuser -X GET --header 'Accept: application/json' 'http://localhost:8080/magnoliaAuthor/.rest/demo/v1/lunch'
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=8842AE5F355D4E4E188587483B6B0B52; Path=/magnoliaAuthor/; HttpOnly
Pragma: no-cache
Cache-Control: no-cache, no-store, must-revalidate, max-age=0
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Type: application/json;charset=UTF-8
Content-Length: 64
Date: Wed, 05 Jul 2017 16:51:29 GMT

{"id":"17f552a0-11e8-4d5d-898b-ecf17f05b1ba","food":"Svíčková na smetaně ","beverage":"Gambrinus Plzen"}

Note that the payload also contains the property `id`. This property comes from the super class `com.example.rest.pojos.BasicStorable` of `Lunch`; we will need this id later on.

Both approaches to produce payload with POJOs shown here work in more complex scenarios. For example: you could return a list of POJOs; the properties of the POJO could also be POJOs; and so on.

#### [](#_receiving_payload_and_getting_the_pojo)Receiving payload and getting the POJO

Endpoint methods that receive a payload (JSON or XML) are typically used to create or update an object.

Let’s imagine an example where the endpoint allows you add a lunch object to a store. In the context of a data store, adding is like creating. To create an object, a REST service is called with the the HTTP method `PUT`.

This code snippet shows the method to add a lunch:

com.example.rest.service.v1.DemoEndpoint#storeLunch

[DemoEndpoint.java?]({repo-demoRestServices})

-   Line 140: It is generally considered good practice to tell the service what type of data it consumes. However, it is not required.

-   Line 143: The most important point in the current context is the method signature.
    **The method must contain a parameter of the type to which the payload should be mapped to.**

-   Line 146: If the mapping was successful, we add the lunch POJO to the store. The `store` actually is a mock store, it does not really store data in the example. (See [`BlackboxDatastore.java`]({repo-demoRestServices}) on Git). However, `store#add` may throw an exception if it fails.

-   Line 147: Build the response with the response code 200 (ok), and also put the lunch object into the payload, it now carries the object id too. Giving back the just created object could be used on a client to render an update UI or to summarize the successful add action.

-   Line 148-150: These lines handle the exception thrown by the store. You can provoke this by sending a payload to the method where the property `food` has the value `Bad food`.


You can test the new method using cURL.

curl -i http://localhost:8080/magnoliaAuthor/.rest/demo/v1/store-lunch \\
-H "Accept: application/json" \\
-H "Content-Type: application/json" \\
-X PUT \\
--user superuser:superuser \\
--data \\
'{"food": "Pizza Napoli", "beverage": "Birra Moretti"}'

HTTP/1.1 200 OK
^Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=7E99151D9036CDA5DC200BA8FE70EACB; Path=/magnoliaAuthor/; HttpOnly
Pragma: no-cache
Cache-Control: no-cache, no-store, must-revalidate, max-age=0
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Type: application/json;charset=UTF-8
Content-Length: 94
Date: Thu, 06 Jul 2017 16:33:04 GMT

{"id":"b64633b7-4555-4571-86b6-8e45bdab61b3","food":"Pizza Napoli","beverage":"Birra Moretti"}

The first attempt was successful! :smile:

Now provoke an error with `Bad food`:

curl -i http://localhost:8080/magnoliaAuthor/.rest/demo/v1/store-lunch \\
-H "Accept: application/json" \\
-H "Content-Type: application/json" \\
-X PUT \\
--user superuser:superuser \\
--data \\
'{ "food": "Bad food", "beverage": "Bud Light"}'

HTTP/1.1 406 Not Acceptable
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=FEA3475D150D8106F8A265E97060BC2F; Path=/magnoliaAuthor/; HttpOnly
Pragma: no-cache
Cache-Control: no-cache, no-store, must-revalidate, max-age=0
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Length: 0
Date: Thu, 06 Jul 2017 16:36:15 GMT

The `Bad food` was rejected. No payload was returned and the HTTP response code is 406 (Not Acceptable).

Implementing a method to update an object (and using the HTTP method `POST`) works in a similar way. In such a case, the payload sent to the REST endpoint must contain the object id in order to update the correct item on the data store.

## [](#_the_same_origin_policy_problem)The same-origin policy problem

Let’s assume you want to use a data API endpoint to serve content managed with Magnolia apps to independent applications located `outside` of Magnolia. For example, you want to use an AngularJS application to display your content.
We also assume Magnolia and the Angular application are hosted on completely different systems.

According to the same-origin policy

> (…) a web browser permits scripts contained in a first web page to access data in a second web page, but only if both web pages have the same *origin*.
>
> [Wikipedia](https://en.wikipedia.org/wiki/Same-origin_policy)

Therefore, if your application resides within a domain that is different from the domain that hosts your data, the web browser will actively prevent accessing content stored under the host domain.

An elegant solution to solve the same-origin policy without changing Apache configuration is the Magnolia [Add HTTP Headers](../../../Administration/Architecture/Request-processing-and-filters/Filters/) filter. This filter is available out-of-the-box; you only need to configure it.

## [](#_sample_code_on_git)Sample code on Git

The sample code for the examples on this page is available on the [Magnolia Git repository]({repo-demoRestServices}).

Related topics

-   [Getting started with REST](../../../Getting-started-with-Magnolia/Getting-started-with-REST/)

-   [REST module](../../../../../rest/)

-   [How to get content as JSON - an overview](../How-to-get-content-as-JSON-an-overview/)
