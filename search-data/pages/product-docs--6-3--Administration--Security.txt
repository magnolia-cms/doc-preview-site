---
title: "Security"
url: https://docs.magnolia-cms.com/product-docs/6.3/Administration/Security/
category: Magnolia 6.3
version: 6.3
breadcrumb: DX Core > Administration > Security
---

# Security

This page provides a list of hardening measures to improve the security of your Magnolia setup.

> **Tip:** For information about how to manage users, groups, roles, permissions, and authentication, see Identity and access management (IAM).

## [](#_underlying_technologies)Underlying technologies

### [](#_jcr)JCR

Magnolia uses the Jackrabbit reference implementation of the Java Content Repository (JCR) 2.0 standard. ACL checks are performed at the JCR level. This low-level check has the following benefits:

-   Better performance than checking in the application code.

-   Repository can be exposed to third-party apps. Access Control Lists (ACLs) still apply.

-   Use JCR API directly without the need to wrap objects.


> **Caution:** Resources on classpath should not contain sensitive information (for example passwords or api keys) as this type of information could be exposed via the Resource Files app.

## [](#_filters)Filters

### [](#_web_access)Web access

Every request sent to Magnolia is checked by info.magnolia.cms.security.URISecurityFilter. The filter checks whether the role(s) of the requesting user allow(s) the user to request a given path with the given method.

Web permissions are granted as web access lists per role. They grant access to a path for **Get** or **Get & Post**.

-   **Get** - Grants the HTTP `GET` method for a given URI.

-   **Get & Post** - Grants the HTTP `GET`, `PUT`, `POST`, and `DELETE` methods for a given URI.


### [](#_cross_site_security)Cross-site security

The cross-site security filter is executed in the Magnolia filter chain before the URI security filter. A user must pass the cross-site filter before authentication or authorization through ACLs. The cross-site filter allows or denies permission to a site based on its domain name. For more information, see [Cross-site security](../Architecture/Request-processing-and-filters/Filters/#_cross_site_security).

### [](#_app_permissions)App permissions

Provision apps only to users who need them, following the Principle of Least Privilege ([PoLP](https://en.wikipedia.org/wiki/Principle_of_least_privilege)). Each user should only have access to the resources necessary for their role, and no more. For more information, see [App permissions](../IAM/App-permissions/).

## [](#_content)Content

> **Note:** Since content and templates are usually customized or completely developed by the users of Magnolia, it is your responsibility to ensure that developed content is not exploitable by cross-site scripting, HTML injection or similar attacks. For templates provided with Magnolia, the system tries to ensure that there are no such vulnerabilities.

FreeMarker provides various built-in HTML and JavaScript escaping functions to ensure that templates donâ€™t suffer from the vulnerabilities mentioned above. In case of concerns regarding security, Magnolia Support treats all security-related issues with the highest possible urgency and always tries to provide customers with a workaround or temporary fix for any issues.

### [](#_http_requests)HTTP requests

HTTP requests can be accessed either with `ctx.getRequest()` (in templates) or with `info.magnolia.context WebContext#getRequest` (in code).

To prevent [XSS exploits](https://owasp.org/www-community/attacks/xss/), the following HTTP request content is always escaped:

-   Header values.

-   Cookie values.

-   Parameters (names and values).


> **Caution:** This policy, introduced with Magnolia 6.2.14, may break code functionality or templates which rely on the original unescaped values.Developers may unescape header values by using:cmsfn.unescapeXss() (in templates)info.magnolia.util.EscapeUtil#unescapeXss(java.lang.String) (in code)

### [](#_http_headers_and_security_best_practices)HTTP headers and security best practices

In this subsection, we provide some ideas how you can improve security through select HTTP headers.

#### [](#_content_security_policy_csp_header)Content Security Policy (CSP) header

Content Security Policy governs what a web browser (or a user agent, in general) is allowed to load as part of a page. Setting a CSP header allows the creator of a page to control what other resources might be loaded by the underlying HTML or JavaScript code. This is a powerful way to mitigate many Cross-site scripting (XSS) and clickjacking attacks.

> **Important:** CSP configuration is mandatory for production deployments. You should configure a restrictive CSP on all HTML resources before deploying to production.CSP Level 2 is supported by all major browsers and should be used for production deployments.

You should list, as part of the header value, the origin and all the endpoints required for the page to function. However, if you allow any endpoint that is not within your control, you are opening a hole through which an attack might be staged.

If necessary, we recommend you customize the header to define your own whitelist.

There are two ways to configure the Content Security Policy header:

-   **Per-site configuration (recommended)**: This approach provides more granular control over your security policies. You can configure CSP for each site directly within its site definition. See [Content-Security-Policy (CSP) Filter](../Architecture/Request-processing-and-filters/csp/) for detailed instructions and examples.

-   **Global configuration**: You can configure a global CSP header by creating a new filter in the [Configuration app](../../Apps/List-of-apps/Configuration-app/). This approach is less flexible than the per-site configuration but can help apply a single policy to all sites.

    An example configuration could look similar to the one below. The path `server/filters/HeaderFilterOne` is only a suggestion. When adding CSP headers, you only need to place the header values into the `Content-Security-Policy` property.

    |     |     |
    | --- | --- |
    | ðŸ“ server |     |
    | ðŸ“ filters |     |
    | ðŸ“ HeaderFilterOne |     |
    | â¬© class | info.magnolia.cms.filters.AddHeadersFilter |
    | â¬© enabled | true |
    | ðŸ“ headers |     |
    | â¬© Content-Security-Policy | default-src \`self' \`unsafe-inline' \`unsafe-eval' [https://ga-dev-tools.appspot.com](https://ga-dev-tools.appspot.com) [https://apis.google.com](https://apis.google.com) [https://www.google.com](https://www.google.com) [https://content.googleapis.com](https://content.googleapis.com) [https://ajax.googleapis.com](https://ajax.googleapis.com) ; img-src \`self' data:; |


> **Note:** The Vaadin framework performs the CSP check explicitly instead of relying on browser to do so as part of policy execution. You can see official Vaadin statement here.

##### [](#_strong_csp_level_2_policy_example)Strong CSP level 2 policy example

For production deployments, use a restrictive CSP Level 2 policy such as the example one below.

```text
Content-Security-Policy: default-src 'none'; script-src 'nonce-r4nd0mN0nce'; frame-ancestors 'none'; base-uri 'self'; form-action 'self'; report-uri https://cspreport.example.com/log
```

This policy:

-   `default-src 'none'` - Blocks all resources by default

-   `script-src 'nonce-r4nd0mN0nce'` - Only allows scripts with the specified nonce

-   `frame-ancestors 'none'` - Prevents the page from being embedded in frames (clickjacking protection)

-   `base-uri 'self'` - Restricts base element URLs to same origin

-   `form-action 'self'` - Restricts form submissions to same origin

-   `report-uri` - Sends violation reports to the specified endpoint


##### [](#_development_configuration)Development configuration

During development, you can enable reporting of violations without blocking content by using the `Content-Security-Policy-Report-Only` header instead of `Content-Security-Policy`. This allows you to test and refine your policy before enforcing it in production.

##### [](#_json_requests_are_processed_when_content_type_is_textplain)JSON requests are processed when Content-Type is text/plain?

This does not present a security vulnerability in Vaadin. Vaadin doesnâ€™t enforce `Content-Type: application/json` because it doesnâ€™t rely on it for security.

Requests with an incorrect `Content-Type` fail if the content is malformed. This ensures compatibility with technologies like Portlets. For more details, see [Advanced Vaadin Topics: Content Type Incorrectly Stated](https://vaadin.com/docs/latest/flow/security/advanced-topics/frequent-issues#content-type-incorrectly-stated).

Vaadin secures requests using CSRF tokens, not `Content-Type` validation.

##### [](#_csp_evaluation_and_testing)CSP evaluation and testing

Use the [CSP Evaluator tool](https://csp-evaluator.withgoogle.com/) to test and validate your Content Security Policy configuration. This tool helps identify potential security issues and provides recommendations for improving your policy.

See also

-   [github.com: Insufficient Content-Type: application/json Validation](https://github.com/vaadin/framework/issues/9492#issuecomment-306716024)

-   [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)

-   [MDN: Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)


#### [](#_strict_transport_security_sts_header)`Strict-Transport-Security` (STS) header

The STS header informs the browser that a page should only be accessed over the HTTPS protocol. The browser will use this knowledge and set all future requests for the same domain to go through HTTPS automatically, thus preventing the extra round trip that might be required otherwise.

Using HTTPS instead of HTTP enables traffic encryption between the page and the client, preventing anyone from intercepting the communication. Using this header is considered more secure than using the 301 redirect on the server when an attempt for the over-the-HTTP access is made.

See also:

-   [HSTS - Web Security Best Practices](https://www.checkbot.io/guide/security/hsts/)

-   [MDN: Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)


#### [](#_x_content_type_options_xcto_header)`X-Content-Type-Options` (XCTO) header

XCTO is a marker header that tells the client that the media types (MIME types) advertized as part of the Content-Type headers should be strictly followed and not changed. This helps avoid *MIME Type Sniffing*.

See also:

-   [MDN: X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options)


#### [](#_x_frame_options_xfo_header)`X-Frame-Options` (XFO) header

Setting the XFO header tells the browser that the given page is not allowed to be embedded in another page. This header setting helps mitigate stealing content, *clickjacking* (UI redress attack) or allowing malicious sites to pose as the regular ones and fool the users to not check the URLs closely but think instead that they are on a safe page when they are actually not.

See also:

-   [Current best practices to restrict framing in the browser](https://pragmaticwebsecurity.com/articles/securitypolicies/preventing-framing-with-policies.html)

-   [MDN: X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)


### [](#_rest_requests)REST requests

Endpoints always require [URI access](../../Modules/List-of-modules/REST-module/REST-security/#_web_access_security). They may also require [JCR access](../../Modules/List-of-modules/REST-module/REST-security/#_jcr_access_security) or a specific role defined at a [command level](../../Modules/List-of-modules/REST-module/REST-security/#_command). The REST module itself installs four [default roles](../../Modules/List-of-modules/REST-module/REST-security/#_rest_roles).

### [](#_publishing)Publishing

The publishing authentication mechanism requires no configuration. The first time content is published, it automatically generates the [public key](Publishing-security/#_configuration), which is then transferred to the public instance.

## [](#_policies)Policies

When it comes to ensuring a secure platform, there are a few things you need to keep in mind. Youâ€™ll want to take steps to minimize risks, follow established standards, and proactively manage any vulnerabilities or security issues that may arise. Doing so can help ensure that your platform stays safe and secure for all users. For more information, see [Security policy](Security-policy/#_magnolia_is_only_as_secure_as_your_project_implementation).

A short checklist of important security considerations is summed up in [Best practices for a secure Magnolia environment](Security-best-practices/#_best_practices_for_a_secure_magnolia_environment).

## [](#_external_security)External security

External security is achieved via servlet container features. The strength of security depends on the container used to run Magnolia. To improve security, Magnolia recommends that you run the Apache Web Server or another proxy server in front of the application server.

To minimize the risk of attacks on user accounts on a public instance, limit user accounts to the required number and type.

Disable external access to AdminCentral (URIs starting with `./magnolia`) from public IP addresses. Then specify the IP addresses from which users should have permission to log into AdminCentral. See [IP and HTTP permissions](IP-and-HTTP-permissions/).
