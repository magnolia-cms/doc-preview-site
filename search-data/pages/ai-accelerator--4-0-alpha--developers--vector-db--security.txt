---
title: "Security and permissions"
url: https://docs.magnolia-cms.com/ai-accelerator/4.0-alpha/developers/vector-db/security/
category: Modules
version: modules
breadcrumb: AI Accelerator module > Security and permissions
---

# Security and permissions

## [](#_security_overview)Security overview

The Vector Database integration implements a **three-layer security model** to ensure that search results respect Magnolia’s permission system. Users can only see content they’re authorized to access.

> **Important:** Security Principle: AI responses must NEVER expose content that users don’t have permission to read in Magnolia.

## [](#_three_layer_security_model)Three-layer security model

![diagram](https://kroki.io/mermaid/svg/eNp9VMFu00AQvfcrRpaQ0yppqFMuEarUpo0oKgjaAIcoh816HK9q75rddZNIPXDiA-DKiU_rlzC7thOnjfDBXsnvzb6ZNzNJppY8ZdrC5PIA6Pleol5Pgy8GNXx25yGEYyFjsJo9YAYxGisks0JJEwazA08y5XyhWZFCxtaoT6bBjfvCyRA-lJkVvW9K35uCcYTz0Q2MRWZRC7kgOtQPrig-t9PgqjpASQJC4_EFs4SXZvh2rvtnTz_-wrKJN4Qlzo2w2HWo1AyhX-nsH3Whz-aqtP2jfbR5phZbTqGMNf2jlp7Ea5wGd-hSV_AVuVUaLi9gKWwKOVoWM8tq3FZZgToXxrjqwPVHmIYbPWEXwkaRP9eXhrOX-ipqnZoDO7nhrKVvjhITYQ3V-unPbxgzY6HQ2Eua2gKz4BTOmUHIkCRU1xD4FuOSowHOZCwIQ8eEcqs8i-CB-Ing3uL6RirCPqOjxuhoCO9Ht_BpkzzV60UQX1a0PJ0GY7oOGU-3EqoKnhzD2CFAqhgh0Sr3cUvjEqo7wqC_weOjY5jotfNHI4srVkejKcgt46ktPw49ZXAM1wnlwakCJikzePr5C4TkWUlcISmQoZY1HnvqsTFKgbHHVdUF8nCPFVFlxXlpU6WFpdQfsHU_8BT5_caEd5R55kxQeZHhyjW66YJWmVORogsgObV1vJYsFxx0SeiWhXWOJG5d_QMKSAIl9sgh-sTt3P_v46DxcTCEybh3fTmmC6hnnAI6aSbvd6eVs4xPgxG9y4zMo6I1aMMVVXA7D3U4I3KRMUpqDZ3T169oasUitYcb2NXKzXzOnPedaA9gQrlQg6sVBXJB9mH8uqKCUgOzBe5gWtqN0rRm7ugN8_Vz5dBJCU8rjiqpzQ6vsXlQ2XyBbilBXRuwKZM0OX5JtJJlmZK4cW1ETogYtQHr0hF5QSr85c47v3nBWF1yW2p8bln1u9c7a3alP9cd6Y6blXCwsyDcv8dbpJC0QeHkTWvsH6t53GFHO-zIs6thxpjoUTMgj74JPNVVdCfGYCfGwP-raNOgUuIDUemoS-t4wewfSkg45Q==)

## [](#_layer_1_acl_pre_filtering)Layer 1: ACL pre-filtering

### [](#_how_it_works)How it works

The `UserPermissionService` extracts the user’s allowed paths from Magnolia ACLs:

```java
public List<String> getAllowedPaths(User user, List<String> workspaces) {
    List<String> patterns = new ArrayList<>();

    for (String workspace : workspaces) {
        AccessControlList acl = user.getACL(workspace);

        for (Permission permission : acl.getPermissions()) {
            if (permission.allows(Permission.READ)) {
                patterns.add(permission.getPath());
            }
        }
    }

    return patterns; // e.g., ["/travel/*", "/about/*", "/blog/posts/*"]
}
```

These patterns are sent as metadata filters to the vector database:

```json
{
  "filters": {
    "permissions": {
      "$in": ["/travel/*", "/about/*", "/blog/posts/*"]
    },
    "workspace": {
      "$in": ["website", "blog"]
    }
  }
}
```

### [](#_why_layer_1_is_necessary)Why Layer 1 is necessary

Without Layer 1, the vector database would return ALL similar content, then Layer 2 would filter it out. This is inefficient:

-   **Without Layer 1**: Query returns 1000 candidates → Layer 2 filters to 10 results (99% filtered)

-   **With Layer 1**: Query returns 15 candidates → Layer 2 filters to 12 results (20% filtered)


Layer 1 dramatically reduces the amount of work Layer 2 must do.

### [](#_limitations)Limitations

Layer 1 is **permission pattern matching**, not authoritative permission checking:

-   ✅ Handles path-based permissions: `/travel/*`, `/about/company`

-   ✅ Filters by workspace access

-   ⚠️ Cannot handle complex deny rules

-   ⚠️ Cannot handle dynamic permissions based on content state

-   ⚠️ Cannot handle role-based computed permissions


This is why Layer 2 is essential.

## [](#_layer_2_jcr_permission_verification)Layer 2: JCR permission verification

### [](#_how_it_works_2)How it works

For each candidate from Layer 1, verify actual JCR permissions:

```java
private boolean hasJcrAccess(User user, String path, String workspace) {
    try {
        Session session = getSessionFor(user, workspace);
        Node node = session.getNode(path);

        // Successfully retrieved node = user has read permission
        return true;

    } catch (PathNotFoundException e) {
        // Node doesn't exist or user can't see it
        return false;
    } catch (AccessDeniedException e) {
        // User explicitly denied access
        return false;
    }
}
```

### [](#_why_layer_2_is_essential)Why Layer 2 is essential

Layer 2 provides **authoritative permission checking**:

-   ✅ Respects complex ACL rules (deny rules, role inheritance)

-   ✅ Handles dynamic permissions (publication status, workflow state)

-   ✅ Respects fine-grained permissions (node-level, property-level)

-   ✅ Handles cases where content was deleted but still in vector DB

-   ✅ Respects Magnolia’s security interceptors and custom security rules


### [](#_performance_considerations)Performance considerations

Layer 2 requires a JCR read for each candidate:

-   10 candidates = 10 JCR reads (~50ms total)

-   100 candidates = 100 JCR reads (~500ms total)

-   1000 candidates = 1000 JCR reads (~5000ms total)


This is why Layer 1 pre-filtering is crucial for performance.

| Factor | Description | Weight |
| --- | --- | --- |
| `TF-IDF Similarity` | Term frequency-inverse document frequency similarity between query and content | 40% |
| `Exact Match` | Bonus for exact keyword matches | 20% |
| `Proximity` | Bonus for query terms appearing close together | 20% |
| `Coverage` | Bonus for covering more query terms | 20% |

## [](#_permission_indexing)Permission indexing

### [](#_how_permissions_are_stored)How permissions are stored

During indexing, each document stores ACL patterns as metadata:

```json
{
  "id": "magnolia:/website/travel/paris",
  "content": "Paris is the capital of France...",
  "embedding": [0.123, -0.456, ...],
  "metadata": {
    "path": "/travel/paris",
    "workspace": "website",
    "permissions": [
      "/travel/*",      (1)
      "/travel/paris"   (2)
    ]
  }
}
```

|     |     |
| --- | --- |
| **1** | Content is accessible to users with read permission to `/travel/*` |
| **2** | Content is accessible to users with read permission to `/travel/paris` |

### [](#_acl_pattern_extraction)ACL pattern extraction

The system extracts all ACL patterns that could grant access:

```java
public List<String> extractAccessPatterns(String path) {
    List<String> patterns = new ArrayList<>();

    // Add exact path
    patterns.add(path); // e.g., "/travel/paris"

    // Add parent paths with wildcard
    String[] parts = path.split("/");
    StringBuilder pathBuilder = new StringBuilder();

    for (int i = 1; i < parts.length; i++) {
        pathBuilder.append("/").append(parts[i]);
        patterns.add(pathBuilder + "/*"); // e.g., "/travel/*"
    }

    return patterns; // ["/travel/paris", "/travel/*", "/*"]
}
```

This allows efficient filtering: if user has permission to `/travel/*`, they can access all travel content.

## [](#_workspace_based_security)Workspace-based security

### [](#_workspace_isolation)Workspace isolation

Content from different workspaces is isolated:

```bash
# User A has access to 'website' but not 'intranet'
curl -X POST http://localhost:8080/.rest/context-search/v1/search \
  -d '{
    "query": "company policies",
    "workspaces": ["website", "intranet"]
  }'

# Result: Only content from 'website' returned
# Content from 'intranet' filtered out by Layer 1
```

### [](#_multi_workspace_search)Multi-workspace search

Users can search multiple workspaces if they have access:

```yaml
# User permissions
website: /*, READ
blog: /posts/*, READ
docs: NONE

# Search request
workspaces: ["website", "blog", "docs"]

# Result: Content from website + blog only
```

## [](#_role_based_access_control)Role-based access control

### [](#_superuser_access)Superuser access

Superusers bypass Layer 1 filtering:

```java
if (user.hasRole("superuser")) {
    // Skip ACL filtering, query all content
    return vectorDbService.search(query, workspaces, maxResults);
} else {
    // Apply ACL filtering
    List<String> allowedPaths = userPermissionService.getAllowedPaths(user, workspaces);
    return vectorDbService.searchWithFilters(query, workspaces, allowedPaths, maxResults);
}
```

> **Caution:** Superusers can see ALL indexed content. Use superuser role carefully.

### [](#_role_inheritance)Role inheritance

Permissions are computed based on role hierarchy:

```text
User: editor
Roles: editor, base
Permissions:
  - From 'editor' role: /travel/*, READ
  - From 'base' role: /about/*, READ
Effective permissions: /travel/*, /about/*
```

## [](#_security_best_practices)Security best practices

### [](#_principle_of_least_privilege)Principle of least privilege

Only index content that users need to search:

```yaml
# Don't index sensitive workspaces
workspaces:
  internal-hr: (1)
    enabled: false

  website: (2)
    enabled: true
```

|     |     |
| --- | --- |
| **1** | Don’t index HR workspace |
| **2** | Only index public website |

### [](#_exclude_sensitive_paths)Exclude sensitive paths

Explicitly exclude sensitive paths from indexing:

```yaml
workspaces:
  website:
    excludedPaths:
      - /jcr:system
      - /modules
      - /internal
      - /admin-only
```

### [](#_use_layer_2_verification_always)Use Layer 2 verification always

Never disable Layer 2 verification, even for performance:

```java
// ❌ NEVER DO THIS
if (user.hasRole("trusted")) {
    return resultsWithoutVerification; // SECURITY VULNERABILITY
}

// ✅ ALWAYS DO THIS
return verifyJcrPermissions(results, user); // Always verify
```

### [](#_monitor_permission_denials)Monitor permission denials

Log when Layer 2 filters out content:

```text
[DEBUG] Layer 1 returned 50 candidates
[DEBUG] Layer 2 filtered out 15 results (no permission)
[DEBUG] Final results: 35
[WARN] High filter rate (30%) - consider improving ACL pattern extraction
```

### [](#_regular_security_audits)Regular security audits

Periodically verify that search results respect permissions:

```bash
# Test 1: User without permissions
curl -u user:pass http://localhost:8080/.rest/context-search/v1/search \
  -d '{"query": "admin content"}' | jq '.results'
# Expected: Empty or only public content

# Test 2: User with limited permissions
curl -u editor:pass http://localhost:8080/.rest/context-search/v1/search \
  -d '{"query": "content"}' | jq '.results[].metadata.path'
# Expected: Only paths matching editor's ACL patterns

# Test 3: Superuser
curl -u admin:pass http://localhost:8080/.rest/context-search/v1/search \
  -d '{"query": "content"}' | jq '.results | length'
# Expected: All matching content
```

## [](#_security_limitations)Security limitations

### [](#_published_vs_unpublished_content)Published vs unpublished content

> **Warning:** Known Limitation: The system does not currently distinguish between published and unpublished content.If a workspace contains both draft and published pages, both will be indexed and searchable.

**Workaround**: Only index the public workspace:

```yaml
workspaces:
  website-public: (1)
    enabled: true
    workspace: website-public

  website: (2)
    enabled: false
```

|     |     |
| --- | --- |
| **1** | Index public workspace (published content) |
| **2** | Don’t index author workspace (includes drafts) |

**Future Enhancement**: Add `published: true/false` metadata and filter unpublished content.

### [](#_dynamic_content_permissions)Dynamic content permissions

Permissions based on content state (workflow, publication) are not indexed:

```java
// This permission logic is NOT captured during indexing
if (page.getState().equals("published") && page.getPublicationDate().before(now())) {
    return true; // User can see published content
}
```

Layer 2 verification handles this, but Layer 1 cannot pre-filter based on dynamic state.

## [](#_troubleshooting)Troubleshooting

### [](#_user_sees_content_they_shouldnt)User sees content they shouldn’t

**Symptom**: Search returns content user shouldn’t access

**Investigation**:

1.  Check Layer 2 verification is enabled (it should always be)

2.  Verify user’s actual JCR permissions: open Magnolia AdminCentral, try to access the node

3.  Check if user has superuser role (bypasses filtering)

4.  Review ACL configuration in Magnolia


### [](#_user_cant_find_content_they_should_see)User can’t find content they should see

**Symptom**: Search doesn’t return content user has permission to access

**Investigation**:

1.  Verify content is indexed (check Context Dashboard)

2.  Check if content path matches user’s ACL patterns

3.  Verify workspace is included in search request

4.  Check Layer 1 filtering logs (enable DEBUG logging)

5.  Try reindexing the workspace


### [](#_slow_search_for_users_with_many_permissions)Slow search for users with many permissions

**Symptom**: Search is slow for users with access to many paths

**Solutions**:

-   Layer 1 filtering is efficient even with many patterns

-   Check if Layer 2 is verifying too many candidates (check logs)

-   Consider caching permission lookups

-   Monitor JCR session performance


## [](#_next_steps)Next steps

-   [Customize security behavior](../customization/)

-   [Configure user roles and permissions](../../configure/)

-   [Test search with different user roles](../search/)
