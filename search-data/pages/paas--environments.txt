---
title: "Environments"
url: https://docs.magnolia-cms.com/paas/environments/
category: DX Cloud
version: cloud
breadcrumb: DX Cloud > Environments
---

# Environments

| Environment | Description |
| --- | --- |
| `dev` | The `dev` , or development, environment is typically used for active development where developers build out the project. ** This is typically the starting environment for your project. | ** | This is typically the starting environment for your project. |
| ** | This is typically the starting environment for your project. |
| `uat` | The `uat` , or User Acceptance Testing, environment is often used to validate and test the software developed by the developers in the `dev` environment. Hence, the "acceptance" part of the name. ** Typically, the environment flow moves from `dev` > `uat` > `prod` . | ** | Typically, the environment flow moves from `dev` > `uat` > `prod` . |
| ** | Typically, the environment flow moves from `dev` > `uat` > `prod` . |
| `prod` | The `prod` , or production, environment is the actual live environment and is implemented after `uat` . |

## [](#_feature_environments)Feature environments

If your DX Cloud project requires that you have different environments than the default 3 environments (*dev, uat, prod*), you can configure your [`.gitlab-ci.yml`](#gitlab-ci-file) file to have whatever environments you like.

A typical use-case for this would be temporary feature environments where you work on a new feature or improvement that you want to see fully before it goes into `uat` and onto `prod`. You can do this by ensuring your [`.gitlab-ci.yml`](#gitlab-ci-file) file is configured to reflect the name of those environments.

> **Tip:** See Feature environments for steps on creating a temporary feature environment.

> **Note:** Once configured in the .gitlab-ci.yml file, you can easily view and manage your environments directly from the Cockpit.

## [](#gitlab-ci-file)The `.gitlab-ci.yml` file

Itâ€™s important that you configure the `.gitlab-ci.yml` file correctly so that your development changes are picked up and deployed. If you are using a different CI/CD pipeline, you can use this file as a blueprint.

> **Note:** Magnolia automatically picks up the changes when using this approach.

.`gitlab-ci.yml`

```yaml
# Use the latest Maven version

stages:
  - build
  - push
  - deploy

variables:
  MAVEN_OPTS: "-Dhttps.protocols=TLSv1.2 -Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=WARN -Dorg.slf4j.simpleLogger.showDateTime=true -Djava.awt.headless=true"
  MAVEN_CLI_OPTS: "-s .m2/settings.xml --batch-mode --errors --fail-at-end --show-version -DinstallAtEnd=true -DdeployAtEnd=true"

# Build the Maven project.
build-magnolia: (1)
  image: maven:3.6-jdk-11-slim
  stage: build
  cache:
    key: "$CI_JOB_NAME"
    paths:
      - $CI_PROJECT_DIR/.m2/repository
  before_script:
    - mkdir -p $CI_PROJECT_DIR/.m2
  script:
    - mvn $MAVEN_CLI_OPTS package
    - ls -Fahl base-webapp/target
  artifacts:
    expire_in: 30 days
    paths:
      - base-webapp/target/*.war

# Build docker images based on artifacts from the build stage.
push-docker-image: (2)
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  stage: push
  dependencies:
    - build-magnolia
  before_script:
    - export WEBAPP_IMAGE=${CI_REGISTRY_IMAGE}/magnolia-webapp
    - export GIT_TAG=$CI_COMMIT_SHORT_SHA (3)
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json (4)
  script:
    - cd base-webapp
    - /kaniko/executor --context . --dockerfile ./Dockerfile --destination "$WEBAPP_IMAGE:$GIT_TAG"

.deploy: (5)
  image: registry.gitlab.com/mironet/helm-kubectl-gomplate:v0.0.5
  stage: deploy
  before_script:
    - export GIT_TAG=$CI_COMMIT_SHORT_SHA
    - helm repo add mironet https://charts.mirohost.ch/
    - export HELM_CHART_VERSION={helm-chart-version}
    - export KUBECONFIG=$KUBE_CONFIG (6)
    - chmod 600 $KUBE_CONFIG (6)

deploy-dev: (7)
  extends: .deploy
  script:
    - export DEPLOYMENT=dev
    - export LE_ENVIRONMENT=letsencrypt-prod
    - cat values.yml | gomplate > ${DEPLOYMENT}.yml
    - cat ${DEPLOYMENT}.yml
    - kubectl create namespace ${DEPLOYMENT} --dry-run=client -o yaml | kubectl annotate --local -f - field.cattle.io/projectId=`kubectl get namespace default --output="jsonpath={.metadata.annotations.field\.cattle\.io/projectId}"` -o yaml  | kubectl apply -f - (8)
    - |
      sleep 2
      until kubectl get namespace ${DEPLOYMENT}; do
        echo "Waiting for namespace ${DEPLOYMENT} to be created..."
        sleep 2
      done
    - helm upgrade -i ${DEPLOYMENT} mironet/magnolia-helm --version ${HELM_CHART_VERSION} -f ${DEPLOYMENT}.yml -n ${DEPLOYMENT} (9)
    - kubectl -n default get secret gitlab -o json | jq 'del(.metadata.annotations,.metadata.labels,.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.namespace,.metadata.creationTimestamp)' | kubectl apply -n ${DEPLOYMENT}  -f - (10)
    - kubectl -n default get secret s3-backup-key -o json | jq 'del(.metadata.annotations,.metadata.labels,.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.namespace,.metadata.creationTimestamp)' | kubectl apply -n ${DEPLOYMENT}  -f - (10)
  environment:
    name: dev (11)
  when: manual (12)

deploy-uat: (7)
  extends: .deploy
  script:
    - export DEPLOYMENT=uat
    - export LE_ENVIRONMENT=letsencrypt-prod
    - cat values.yml | gomplate > ${DEPLOYMENT}.yml
    - cat ${DEPLOYMENT}.yml
    - kubectl create namespace ${DEPLOYMENT} --dry-run=client -o yaml | kubectl annotate --local -f - field.cattle.io/projectId=`kubectl get namespace default --output="jsonpath={.metadata.annotations.field\.cattle\.io/projectId}"` -o yaml  | kubectl apply -f - (8)
    - |
      sleep 2
      until kubectl get namespace ${DEPLOYMENT}; do
        echo "Waiting for namespace ${DEPLOYMENT} to be created..."
        sleep 2
      done
    - helm upgrade -i ${DEPLOYMENT} mironet/magnolia-helm --version ${HELM_CHART_VERSION} -f ${DEPLOYMENT}.yml -n ${DEPLOYMENT} (9)
    - kubectl -n default get secret gitlab -o json | jq 'del(.metadata.annotations,.metadata.labels,.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.namespace,.metadata.creationTimestamp)' | kubectl apply -n ${DEPLOYMENT}  -f - (10)
    - kubectl -n default get secret s3-backup-key -o json | jq 'del(.metadata.annotations,.metadata.labels,.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.namespace,.metadata.creationTimestamp)' | kubectl apply -n ${DEPLOYMENT}  -f - (10)
  environment:
    name: dev (11)
  when: manual (12)
```

<div class="joplin-table-wrapper"><table><tbody><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>In the <code>build-magnolia</code> stage, the web app is built using maven, as with any Magnolia project. If using <a href="../../product-docs/6.3/" class="xref page">Magnolia 6.3</a>, you need Java 17 under <code>build-magnolia.image</code>.<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">build-magnolia:
  image: maven:3.8-openjdk-17-slim</code></pre></div></div></td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>In the <code>push-docker-image</code> stage, the Docker image is built and pushed to the Docker registry (<em>in this case the GitLab registry</em>), using the <code>Dockerfile</code> located in the webapp folder.</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>The <code>GIT_TAG</code> is used to set the tag for the created Docker image.</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>The environment variables are set automatically by GitLab if the GitLab registry is used for the project.<div class="admonitionblock note best"><table><tbody><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>We recommend that you use GitLab.</p></div><div class="ulist"><div class="title"><code>env</code> variables</div><ul><li><p><code>$CI_REGISTRY_USER</code></p></li><li><p><code>$CI_REGISTRY_PASSWORD</code></p></li><li><p><code>$CI_REGISTRY</code></p></li></ul></div></td></tr></tbody></table></div></td></tr><tr><td><i class="conum" data-value="5"></i><b>5</b></td><td>The general <code>deployment</code> stage defines the helm chart repo and the version of the Helm chart to be used in the actual deployments.</td></tr><tr><td><i class="conum" data-value="6"></i><b>6</b></td><td>The <code>KUBE_CONFIG</code> CI/CD variable should be defined as type <code>File</code> and hold KubeConfig of the cluster the deployment should go to. The same variable can be defined in different environment scopes (see <code>11</code>). The <code>chmod</code> command changes the access to the file to avoid warnings.</td></tr><tr><td><i class="conum" data-value="7"></i><b>7</b></td><td>The actual <code>deployment</code> stages define the namespace and prefix for the deployment. These stages can be duplicated for different namespaces (<em>so that deployments can run in parallel on the cluster</em>) and for different clusters (see <code>11</code>).</td></tr><tr><td><i class="conum" data-value="8"></i><b>8</b></td><td>This commands creates a namespace for the deployment and adds to the Rancher <code>default</code> project. A loop is integrated to ensure that the namespace exists before continuing. If the namespace already exists, the command is executed without errors.</td></tr><tr><td><i class="conum" data-value="9"></i><b>9</b></td><td>Helm is using the <a href="https://gitlab.com/mironet/magnolia-helm" target="_blank" rel="noopener">Mironet Helm Chart</a> to deploy the Magnolia App and the corresponding databases using the provided values.yml file (see <a href="../deployment/webapp_deployment/#values-yaml-helm" class="xref page">Helm Values</a>) to the defined namespace.</td></tr><tr><td><i class="conum" data-value="10"></i><b>10</b></td><td>The needed secrets are copied over from the <code>default</code> namespace to the newly created namespace.</td></tr><tr><td><i class="conum" data-value="11"></i><b>11</b></td><td>The environment name corresponds to the environment scope (<code>dev</code> or <code>prod</code>) defined in the <code>Deployments</code> section. In different environments the same variable names can be used.</td></tr><tr><td><i class="conum" data-value="12"></i><b>12</b></td><td>The <code>deployment</code> must be triggered manually.</td></tr></tbody></table></div>
